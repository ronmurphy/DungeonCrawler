<html lang="en"><head><div style="display: none;"></div>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mass Collector</title>
    <meta name="description" content="Grow bigger by collecting objects in this addictive 2D top-down game">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(45deg, #1a1a2e, #16213e);
            color: white;
            overflow: hidden;
            touch-action: none;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #gameCanvas {
            border: 2px solid #0f3460;
            background: #0f1419;
            box-shadow: 0 0 20px rgba(15, 52, 96, 0.5);
        }

        #startMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0, 0, 0, 0.8);
            padding: 30px;
            border-radius: 15px;
            border: 2px solid #0f3460;
            z-index: 100;
        }

        #startMenu h1 {
            color: #4fc3f7;
            margin-bottom: 20px;
            font-size: 2.5rem;
            text-shadow: 0 0 10px #4fc3f7;
        }

        #startMenu p {
            margin: 10px 0;
            font-size: 1.2rem;
            color: #b0bec5;
        }

        #readyBtn {
            background: linear-gradient(45deg, #4fc3f7, #29b6f6);
            border: none;
            padding: 15px 30px;
            font-size: 1.5rem;
            color: white;
            border-radius: 10px;
            cursor: pointer;
            margin-top: 20px;
            font-family: inherit;
            transition: all 0.3s ease;
        }

        #readyBtn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(79, 195, 247, 0.5);
        }

        #gameUI {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 50;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #0f3460;
        }

        #gameUI div {
            margin: 5px 0;
            font-size: 1.2rem;
        }

        .score {
            color: #4fc3f7;
        }

        .mass {
            color: #81c784;
        }

        /* Virtual thumb stick styles */
        #thumbstickContainer {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 100px;
            height: 100px;
            z-index: 100;
            touch-action: none;
            display: none;
        }

        #thumbstickBase {
            position: absolute;
            width: 80px;
            height: 80px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3);
            left: 10px;
            top: 10px;
        }

        #thumbstickKnob {
            position: absolute;
            width: 40px;
            height: 40px;
            background: rgba(79, 195, 247, 0.7);
            border-radius: 50%;
            border: 2px solid #4fc3f7;
            transform: translate(-50%, -50%);
            left: 50%;
            top: 50%;
            transition: transform 0.1s;
        }

        /* Shoot button styles */
        #shootButton {
            position: absolute;
            bottom: 30px;
            right: 30px;
            width: 80px;
            height: 80px;
            background: linear-gradient(45deg, #ff6b6b, #ff5252);
            border-radius: 50%;
            border: 2px solid #ff9e9e;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            touch-action: none;
            display: none;
            box-shadow: 0 0 15px rgba(255, 107, 107, 0.5);
        }

        #shootButton::before {
            content: "";
            position: absolute;
            width: 30px;
            height: 5px;
            background: #333;
            border-radius: 3px;
            transform: rotate(45deg);
            top: 25px;
            left: 25px;
        }

        #shootButton::after {
            content: "";
            position: absolute;
            width: 30px;
            height: 5px;
            background: #333;
            border-radius: 3px;
            transform: rotate(-45deg);
            top: 25px;
            left: 25px;
        }

        #shootButton.active {
            background: linear-gradient(45deg, #ff5252, #ff1744);
            box-shadow: 0 0 20px rgba(255, 82, 82, 0.8);
        }

        @media (max-width: 768px) {
            #startMenu h1 {
                font-size: 2rem;
            }
            
            #startMenu p {
                font-size: 1rem;
            }
            
            #gameUI {
                font-size: 1rem;
            }
            
            #thumbstickContainer, #shootButton {
                display: block;
            }
        }
    </style>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><style>
                        body, html {
                            touch-action: manipulation;
                            user-select: none;
                            -webkit-user-select: none;
                            -webkit-touch-callout: none;
                            -webkit-tap-highlight-color: rgba(0,0,0,0);
                        }
                    </style></head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        
        <div id="startMenu">
            <h1>MASS COLLECTOR</h1>
            <p>ðŸŽ® Touch and drag to move</p>
            <p>ðŸ”µ Collect colored objects to grow</p>
            <p>ðŸŽ¯ Some objects flee - use your crossbow!</p>
            <p>ðŸ“ˆ Get bigger and dominate the field!</p>
            <button id="readyBtn">READY TO GROW</button>
        </div>

        <div id="gameUI" style="display: none;">
            <div class="score">Score: <span id="score">0</span></div>
            <div class="mass">Mass: <span id="mass">10</span></div>
        </div>
        
        <!-- Virtual thumb stick -->
        <div id="thumbstickContainer">
            <div id="thumbstickBase"></div>
            <div id="thumbstickKnob"></div>
        </div>
        
        <!-- Shoot button -->
        <div id="shootButton"></div>
    </div>

    <script>
        class MassCollectorGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.startMenu = document.getElementById('startMenu');
                this.gameUI = document.getElementById('gameUI');
                
                // Control elements
                this.thumbstickContainer = document.getElementById('thumbstickContainer');
                this.thumbstickKnob = document.getElementById('thumbstickKnob');
                this.shootButton = document.getElementById('shootButton');
                
                this.setupCanvas();
                this.initGame();
                this.setupControls();
                
                document.getElementById('readyBtn').addEventListener('click', () => this.startGame());
            }

            setupCanvas() {
                const container = document.getElementById('gameContainer');
                this.canvas.width = Math.min(window.innerWidth - 20, 800);
                this.canvas.height = Math.min(window.innerHeight - 20, 600);
                
                // Adjust for mobile
                if (window.innerWidth < 768) {
                    this.canvas.width = window.innerWidth - 10;
                    this.canvas.height = window.innerHeight - 10;
                }
            }

            initGame() {
                this.gameStarted = false;
                this.gameRunning = false;
                
                // Player properties
                this.player = {
                    x: this.canvas.width / 2,
                    y: this.canvas.height / 2,
                    radius: 15,
                    mass: 10,
                    color: '#4fc3f7',
                    targetX: this.canvas.width / 2,
                    targetY: this.canvas.height / 2,
                    velocity: { x: 0, y: 0 },
                    maxSpeed: 5,
                    crossbowAngle: 0,
                    directionX: 1,  // Default to moving right
                    directionY: 0   // Initially not moving vertically
                };

                // Game state
                this.score = 0;
                this.collectibles = [];
                this.particles = [];
                this.projectiles = [];
                
                // Thumbstick properties
                this.thumbstickActive = false;
                this.thumbstickPosition = { x: 0, y: 0 };
                this.thumbstickBasePosition = { 
                    x: this.thumbstickContainer.offsetLeft + this.thumbstickContainer.offsetWidth / 2,
                    y: this.thumbstickContainer.offsetTop + this.thumbstickContainer.offsetHeight / 2
                };
                this.thumbstickRadius = 40;
                
                this.generateCollectibles();
            }

            generateCollectibles() {
                this.collectibles = [];
                const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#fecca7', '#ff9ff3', '#54a0ff'];
                
                for (let i = 0; i < 25; i++) {
                    let x, y, attempts = 0;
                    
                    // Ensure collectibles don't spawn too close to player
                    do {
                        x = Math.random() * (this.canvas.width - 40) + 20;
                        y = Math.random() * (this.canvas.height - 40) + 20;
                        attempts++;
                    } while (
                        attempts < 50 && 
                        Math.sqrt((x - this.player.x) ** 2 + (y - this.player.y) ** 2) < 100
                    );

                    // Randomly make some collectibles flee
                    const isFleeing = Math.random() < 0.3;
                    
                    this.collectibles.push({
                        x: x,
                        y: y,
                        radius: Math.random() * 8 + 5,
                        color: colors[Math.floor(Math.random() * colors.length)],
                        mass: Math.random() * 5 + 2,
                        pulse: Math.random() * Math.PI * 2,
                        collected: false,
                        fleeing: isFleeing,
                        fleeTimer: 0,
                        immobilized: false,
                        immobilizeTimer: 0
                    });
                }
            }

            setupControls() {
                // Touch controls for thumbstick
                this.thumbstickContainer.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (!this.gameRunning) return;
                    
                    this.thumbstickActive = true;
                    this.updateThumbstick(e.touches[0]);
                });

                this.thumbstickContainer.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (!this.gameRunning || !this.thumbstickActive) return;
                    
                    this.updateThumbstick(e.touches[0]);
                });

                this.thumbstickContainer.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.thumbstickActive = false;
                    this.resetThumbstick();
                });

                this.thumbstickContainer.addEventListener('touchcancel', (e) => {
                    e.preventDefault();
                    this.thumbstickActive = false;
                    this.resetThumbstick();
                });

                // Shoot button controls
                this.shootButton.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (!this.gameRunning) return;
                    
                    this.shootButton.classList.add('active');
                    this.shootCrossbow();
                });

                this.shootButton.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.shootButton.classList.remove('active');
                });

                this.shootButton.addEventListener('touchcancel', (e) => {
                    e.preventDefault();
                    this.shootButton.classList.remove('active');
                });

                // Mouse click to shoot for desktop
                this.canvas.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    if (!this.gameRunning || e.button !== 0) return; // Only left click
                    
                    this.shootCrossbow();
                });

                // Mouse controls for desktop
                this.canvas.addEventListener('mousemove', (e) => {
                    e.preventDefault();
                    if (!this.gameRunning) return;
                    
                    const rect = this.canvas.getBoundingClientRect();
                    this.player.targetX = e.clientX - rect.left;
                    this.player.targetY = e.clientY - rect.top;
                });

                // Touch controls for canvas (fallback)
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (!this.gameRunning) return;
                    
                    const touch = e.touches[0];
                    const rect = this.canvas.getBoundingClientRect();
                    this.player.targetX = touch.clientX - rect.left;
                    this.player.targetY = touch.clientY - rect.top;
                });

                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (!this.gameRunning) return;
                    
                    const touch = e.touches[0];
                    const rect = this.canvas.getBoundingClientRect();
                    this.player.targetX = touch.clientX - rect.left;
                    this.player.targetY = touch.clientY - rect.top;
                });

                // Prevent context menu on touch
                this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
            }
            
            updateThumbstick(touch) {
                const rect = this.thumbstickContainer.getBoundingClientRect();
                const touchX = touch.clientX - rect.left;
                const touchY = touch.clientY - rect.top;
                
                // Calculate distance from center
                const centerX = this.thumbstickContainer.offsetWidth / 2;
                const centerY = this.thumbstickContainer.offsetHeight / 2;
                const dx = touchX - centerX;
                const dy = touchY - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Limit to thumbstick radius
                if (distance > this.thumbstickRadius) {
                    const angle = Math.atan2(dy, dx);
                    this.thumbstickPosition.x = Math.cos(angle) * this.thumbstickRadius;
                    this.thumbstickPosition.y = Math.sin(angle) * this.thumbstickRadius;
                } else {
                    this.thumbstickPosition.x = dx;
                    this.thumbstickPosition.y = dy;
                }
                
                // Update knob position
                this.thumbstickKnob.style.transform = `translate(-50%, -50%) translate(${this.thumbstickPosition.x}px, ${this.thumbstickPosition.y}px)`;
                
                // Update player target position based on thumbstick
                const maxDistance = this.thumbstickRadius;
                const moveX = this.thumbstickPosition.x / maxDistance;
                const moveY = this.thumbstickPosition.y / maxDistance;
                
                this.player.targetX = this.player.x + moveX * 100;
                this.player.targetY = this.player.y + moveY * 100;
            }
            
            resetThumbstick() {
                this.thumbstickPosition = { x: 0, y: 0 };
                this.thumbstickKnob.style.transform = 'translate(-50%, -50%)';
                this.player.targetX = this.player.x;
                this.player.targetY = this.player.y;
            }
            
            updateCrossbowDirection() {
                this.player.crossbowAngle = Math.atan2(this.player.directionY, this.player.directionX);
            }
            
            shootCrossbow() {
                if (!this.gameRunning) return;
                
                // Create a projectile
                const speed = 10;
                const offsetX = Math.cos(this.player.crossbowAngle) * (this.player.radius + 5);
                const offsetY = Math.sin(this.player.crossbowAngle) * (this.player.radius + 5);
                
                this.projectiles.push({
                    x: this.player.x + offsetX,
                    y: this.player.y + offsetY,
                    vx: Math.cos(this.player.crossbowAngle) * speed,
                    vy: Math.sin(this.player.crossbowAngle) * speed,
                    radius: 4,
                    color: '#ffcc00',
                    life: 60 // Will disappear after 60 frames
                });
            }

            updatePlayer() {
                const dx = this.player.targetX - this.player.x;
                const dy = this.player.targetY - this.player.y;
                
                // Calculate direction and distance
                const distance = Math.sqrt(dx * dx + dy * dy);
                const directionX = dx / distance || 0;
                const directionY = dy / distance || 0;
                
                // Store movement direction (if moving significantly)
                if (distance > 5) {
                    this.player.directionX = directionX;
                    this.player.directionY = directionY;
                }
                
                // Smooth movement with speed based on mass
                const speed = Math.max(0.5, 3 - (this.player.mass / 50));
                this.player.x += directionX * speed;
                this.player.y += directionY * speed;

                // Keep player in bounds
                this.player.x = Math.max(this.player.radius, 
                    Math.min(this.canvas.width - this.player.radius, this.player.x));
                this.player.y = Math.max(this.player.radius, 
                    Math.min(this.canvas.height - this.player.radius, this.player.y));
            }

            updateCollectibles() {
                this.collectibles.forEach(collectible => {
                    if (collectible.collected || collectible.immobilized) return;
                    
                    // Update flee timer if active
                    if (collectible.fleeTimer > 0) {
                        collectible.fleeTimer--;
                    }
                    
                    // Fleeing behavior
                    if (collectible.fleeing && collectible.fleeTimer <= 0) {
                        const dx = collectible.x - this.player.x;
                        const dy = collectible.y - this.player.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        // Only flee if player is close enough
                        if (distance < 150) {
                            const fleeSpeed = 0.8;
                            const fleeDirectionX = dx / distance;
                            const fleeDirectionY = dy / distance;
                            
                            collectible.x += fleeDirectionX * fleeSpeed;
                            collectible.y += fleeDirectionY * fleeSpeed;
                            
                            // Keep collectible in bounds
                            collectible.x = Math.max(collectible.radius, 
                                Math.min(this.canvas.width - collectible.radius, collectible.x));
                            collectible.y = Math.max(collectible.radius, 
                                Math.min(this.canvas.height - collectible.radius, collectible.y));
                        }
                    }
                });
            }
            
            updateProjectiles() {
                for (let i = this.projectiles.length - 1; i >= 0; i--) {
                    const projectile = this.projectiles[i];
                    
                    // Move projectile
                    projectile.x += projectile.vx;
                    projectile.y += projectile.vy;
                    projectile.life--;
                    
                    // Check if projectile is out of bounds
                    if (
                        projectile.x < -50 || 
                        projectile.x > this.canvas.width + 50 ||
                        projectile.y < -50 || 
                        projectile.y > this.canvas.height + 50 ||
                        projectile.life <= 0
                    ) {
                        this.projectiles.splice(i, 1);
                        continue;
                    }
                    
                    // Check collision with collectibles
                    this.collectibles.forEach(collectible => {
                        if (collectible.collected || collectible.immobilized) return;
                        
                        const dx = projectile.x - collectible.x;
                        const dy = projectile.y - collectible.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < projectile.radius + collectible.radius) {
                            // Hit! Immobilize the collectible
                            collectible.immobilized = true;
                            collectible.immobilizeTimer = 120; // 2 seconds at 60fps
                            
                            // Create hit particles
                            this.createParticles(collectible.x, collectible.y, '#ffcc00');
                            
                            // Remove projectile
                            this.projectiles.splice(i, 1);
                            return;
                        }
                    });
                }
            }
            
            updateImmobilizedCollectibles() {
                this.collectibles.forEach(collectible => {
                    if (collectible.immobilized) {
                        collectible.immobilizeTimer--;
                        
                        if (collectible.immobilizeTimer <= 0) {
                            collectible.immobilized = false;
                        }
                    }
                });
            }

            checkCollisions() {
                this.collectibles.forEach((collectible, index) => {
                    if (collectible.collected) return;

                    const dx = this.player.x - collectible.x;
                    const dy = this.player.y - collectible.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < this.player.radius + collectible.radius) {
                        // Collect the item
                        collectible.collected = true;
                        this.score += Math.floor(collectible.mass * 10);
                        this.player.mass += collectible.mass;
                        this.player.radius = Math.sqrt(this.player.mass) * 2;

                        // Create particles
                        this.createParticles(collectible.x, collectible.y, collectible.color);

                        // Remove collectible
                        this.collectibles.splice(index, 1);

                        // Generate new collectible
                        if (this.collectibles.length < 20) {
                            setTimeout(() => this.addNewCollectible(), 500);
                        }
                    }
                });
            }

            addNewCollectible() {
                const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#fecca7', '#ff9ff3', '#54a0ff'];
                let x, y, attempts = 0;
                
                do {
                    x = Math.random() * (this.canvas.width - 40) + 20;
                    y = Math.random() * (this.canvas.height - 40) + 20;
                    attempts++;
                } while (
                    attempts < 50 && 
                    Math.sqrt((x - this.player.x) ** 2 + (y - this.player.y) ** 2) < 150
                );

                // Randomly make some collectibles flee
                const isFleeing = Math.random() < 0.3;
                
                this.collectibles.push({
                    x: x,
                    y: y,
                    radius: Math.random() * 8 + 5,
                    color: colors[Math.floor(Math.random() * colors.length)],
                    mass: Math.random() * 5 + 2,
                    pulse: Math.random() * Math.PI * 2,
                    collected: false,
                    fleeing: isFleeing,
                    fleeTimer: 0,
                    immobilized: false,
                    immobilizeTimer: 0
                });
            }

            createParticles(x, y, color) {
                for (let i = 0; i < 8; i++) {
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: (Math.random() - 0.5) * 6,
                        vy: (Math.random() - 0.5) * 6,
                        color: color,
                        life: 30,
                        maxLife: 30
                    });
                }
            }

            updateParticles() {
                this.particles.forEach((particle, index) => {
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.vx *= 0.98;
                    particle.vy *= 0.98;
                    particle.life--;

                    if (particle.life <= 0) {
                        this.particles.splice(index, 1);
                    }
                });
            }

            render() {
                // Clear canvas
                this.ctx.fillStyle = '#0f1419';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Draw grid
                this.ctx.strokeStyle = 'rgba(15, 52, 96, 0.3)';
                this.ctx.lineWidth = 1;
                for (let x = 0; x < this.canvas.width; x += 50) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.canvas.height);
                    this.ctx.stroke();
                }
                for (let y = 0; y < this.canvas.height; y += 50) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvas.width, y);
                    this.ctx.stroke();
                }

                // Draw projectiles
                this.projectiles.forEach(projectile => {
                    this.ctx.beginPath();
                    this.ctx.arc(projectile.x, projectile.y, projectile.radius, 0, Math.PI * 2);
                    this.ctx.fillStyle = projectile.color;
                    this.ctx.fill();
                    
                    // Draw bolt tail
                    this.ctx.beginPath();
                    this.ctx.moveTo(projectile.x, projectile.y);
                    this.ctx.lineTo(
                        projectile.x - Math.cos(this.player.crossbowAngle) * 10,
                        projectile.y - Math.sin(this.player.crossbowAngle) * 10
                    );
                    this.ctx.strokeStyle = 'rgba(255, 204, 0, 0.7)';
                    this.ctx.lineWidth = 2;
                    this.ctx.stroke();
                });

                // Draw collectibles
                this.collectibles.forEach(collectible => {
                    if (collectible.collected) return;
                    
                    collectible.pulse += 0.1;
                    const pulseRadius = collectible.radius + Math.sin(collectible.pulse) * 2;
                    
                    this.ctx.beginPath();
                    this.ctx.arc(collectible.x, collectible.y, pulseRadius, 0, Math.PI * 2);
                    this.ctx.fillStyle = collectible.color;
                    this.ctx.fill();
                    
                    // Draw immobilized effect
                    if (collectible.immobilized) {
                        this.ctx.beginPath();
                        this.ctx.arc(collectible.x, collectible.y, pulseRadius + 3, 0, Math.PI * 2);
                        this.ctx.strokeStyle = 'rgba(255, 204, 0, 0.7)';
                        this.ctx.lineWidth = 2;
                        this.ctx.stroke();
                    }
                    
                    this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    this.ctx.lineWidth = 2;
                    this.ctx.stroke();
                });

                // Draw particles
                this.particles.forEach(particle => {
                    const alpha = particle.life / particle.maxLife;
                    this.ctx.fillStyle = particle.color.replace(')', `, ${alpha})`).replace('rgb', 'rgba');
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, 3 * alpha, 0, Math.PI * 2);
                    this.ctx.fill();
                });

                // Draw player
                this.ctx.beginPath();
                this.ctx.arc(this.player.x, this.player.y, this.player.radius, 0, Math.PI * 2);
                this.ctx.fillStyle = this.player.color;
                this.ctx.fill();
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                this.ctx.lineWidth = 3;
                this.ctx.stroke();

                // Draw player glow
                this.ctx.beginPath();
                this.ctx.arc(this.player.x, this.player.y, this.player.radius + 5, 0, Math.PI * 2);
                this.ctx.strokeStyle = `rgba(79, 195, 247, 0.3)`;
                this.ctx.lineWidth = 2;
                this.ctx.stroke();
                
                // Draw crossbow
                const crossbowLength = this.player.radius + 10;
                this.ctx.beginPath();
                this.ctx.moveTo(
                    this.player.x,
                    this.player.y
                );
                this.ctx.lineTo(
                    this.player.x + Math.cos(this.player.crossbowAngle) * crossbowLength,
                    this.player.y + Math.sin(this.player.crossbowAngle) * crossbowLength
                );
                this.ctx.strokeStyle = '#8B4513'; // Brown for crossbow
                this.ctx.lineWidth = 3;
                this.ctx.stroke();
                
                // Draw crossbow tip
                this.ctx.beginPath();
                this.ctx.arc(
                    this.player.x + Math.cos(this.player.crossbowAngle) * crossbowLength,
                    this.player.y + Math.sin(this.player.crossbowAngle) * crossbowLength,
                    4,
                    0,
                    Math.PI * 2
                );
                this.ctx.fillStyle = '#ffcc00';
                this.ctx.fill();
            }

            updateUI() {
                document.getElementById('score').textContent = this.score;
                document.getElementById('mass').textContent = Math.floor(this.player.mass);
            }

            gameLoop() {
                if (!this.gameRunning) return;

                this.updatePlayer();
                this.updateCrossbowDirection();
                this.updateCollectibles();
                this.updateProjectiles();
                this.updateImmobilizedCollectibles();
                this.checkCollisions();
                this.updateParticles();
                this.render();
                this.updateUI();

                requestAnimationFrame(() => this.gameLoop());
            }
            
            startGame() {
                this.startMenu.style.display = 'none';
                this.gameUI.style.display = 'block';
                
                // Show controls on mobile
                if (window.innerWidth < 768) {
                    this.thumbstickContainer.style.display = 'block';
                    this.shootButton.style.display = 'block';
                }
                
                this.gameStarted = true;
                this.gameRunning = true;
                this.gameLoop();
            }
        }

        // Initialize game when page loads
        window.addEventListener('load', () => {
            new MassCollectorGame();
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            location.reload();
        });
    </script>
<script>
(function() {
    var originalConsoleError = console.error;
    console.error = function() {
        window.parent.postMessage({
            type: 'error',
            message: Array.from(arguments).join(' ')
        }, '*');
        originalConsoleError.apply(console, arguments);
    };

    window.addEventListener('error', function(event) {
        window.parent.postMessage({
            type: 'error',
            message: event.message,
            source: event.filename,
            lineno: event.lineno,
            colno: event.colno,
            error: event.error ? event.error.stack : null
        }, '*');
    });

    window.addEventListener('unhandledrejection', function(event) {
        window.parent.postMessage({
            type: 'error',
            message: 'Unhandled Promise Rejection: ' + event.reason,
            error: event.reason ? event.reason.stack : null
        }, '*');
    });
})();
</script><script defer="" src="https://static.cloudflareinsights.com/beacon.min.js/vcd15cbe7772f49c399c6a5babf22c1241717689176015" integrity="sha512-ZpsOmlRQV6y907TI0dKBHq9Md29nnaEIPlkf84rnaERnq6zvWvPUqr2ft8M1aS28oN72PdrCzSjY4U6VaAw1EQ==" data-cf-beacon="{"version":"2024.11.0","token":"5562e2e56e7244b2af1869a8c731adb3","r":1,"server_timing":{"name":{"cfCacheStatus":true,"cfEdge":true,"cfExtPri":true,"cfL4":true,"cfOrigin":true,"cfSpeedBrain":true},"location_startswith":null}}" crossorigin="anonymous"></script>

<script>
                        let lastTouchEnd = 0;

                        document.addEventListener('touchstart', function(e) {
                            if (e.touches.length > 1) {
                                e.preventDefault();
                            }
                        }, { passive: false });

                        document.addEventListener('touchend', function(e) {
                            const now = (new Date()).getTime();
                            if (now - lastTouchEnd <= 300) {
                                e.preventDefault();
                            }
                            lastTouchEnd = now;
                        }, false);

                        document.addEventListener('touchmove', function(e) {
                            if (e.touches.length > 1) {
                                e.preventDefault();
                            }
                        }, { passive: false });
                    </script></body></html>